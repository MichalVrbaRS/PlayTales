@page "/audiobooks/sleep/{BookId:guid}/{ChapterId:guid}"
@implements IDisposable
@inject PlayTale.Features.Audiobooks.Services.ISleepTimerService SleepTimerService
@inject NavigationManager Navigation

<PageTitle>Sleep Timer</PageTitle>

<section class="screen">
    <header class="header">
        <button type="button" class="link-btn" @onclick="BackToPlayer">‹</button>
        <h1>Sleep Timer</h1>
    </header>

    <div class="card">
        <section class="card__section">
            <label class="label" for="minutes">Stop After</label>
            <div class="presets">
                @foreach (var preset in PresetMinutes)
                {
                    <button type="button"
                            class="preset-chip @(preset == _minutes ? "preset-chip--active" : string.Empty)"
                            @onclick="() => SetPresetMinutes(preset)">
                        @preset min
                    </button>
                }
            </div>
            <select id="minutes" @bind="_minutes">
                <option value="10">10 minutes</option>
                <option value="15">15 minutes</option>
                <option value="20">20 minutes</option>
                <option value="30">30 minutes</option>
                <option value="45">45 minutes</option>
                <option value="60">60 minutes</option>
            </select>
        </section>

        <section class="card__section">
            <label class="label" for="mode">At End Of Current Chapter</label>
            <select id="mode" @bind="_mode">
                <option value="duration">After selected minutes</option>
                <option value="chapter">At end of current chapter</option>
                <option value="chapters">After 2 chapters</option>
            </select>
        </section>

        <div class="actions">
            <button type="button" class="primary-btn" @onclick="StartTimerAsync">▶ Start</button>
            <button type="button" class="secondary-btn secondary-btn--icon" title="Cancel" @onclick="BackToPlayer">✕</button>
        </div>
    </div>

    @if (_state.IsActive)
    {
        <div class="state-card">
            <div class="state-card__headline">
                <span class="state-dot"></span>
                <span class="state-label">Sleep Timer Active</span>
            </div>
            @if (_state.Mode == PlayTale.Features.Audiobooks.Models.SleepTimerMode.Duration && _state.EndsAtUtc is not null)
            {
                <div class="countdown">@FormatRemaining(_state.EndsAtUtc.Value)</div>
            }
            <p class="hint">@GetActiveText(_state)</p>
            <button type="button" class="secondary-btn state-card__button" @onclick="CancelTimerAsync">⏹ Disable</button>
        </div>
    }
    else if (_startedMessage is not null)
    {
        <div class="state-card">
            <p class="hint">@_startedMessage</p>
        </div>
    }
</section>

@code {
    [Parameter]
    public Guid BookId { get; set; }

    [Parameter]
    public Guid ChapterId { get; set; }

    private int _minutes = 15;
    private static readonly int[] PresetMinutes = { 15, 30, 45, 60 };
    private string _mode = "duration";
    private string? _startedMessage;
    private CancellationTokenSource? _countdownCts;
    private PlayTale.Features.Audiobooks.Models.SleepTimerState _state = new()
    {
        Mode = PlayTale.Features.Audiobooks.Models.SleepTimerMode.Off,
        IsActive = false
    };

    protected override void OnInitialized()
    {
        _state = SleepTimerService.CurrentState;
        SleepTimerService.SleepTimerStateChanged += OnSleepTimerStateChanged;
        UpdateCountdownTicker();
    }

    private async Task StartTimerAsync()
    {
        _startedMessage = null;
        switch (_mode)
        {
            case "chapter":
                await SleepTimerService.StartUntilEndOfChapterAsync();
                break;
            case "chapters":
                await SleepTimerService.StartForChapterCountAsync(2);
                break;
            default:
                await SleepTimerService.StartForDurationAsync(TimeSpan.FromMinutes(_minutes));
                break;
        }

        BackToPlayer();
    }

    private void SetPresetMinutes(int minutes)
    {
        _minutes = minutes;
    }

    private async Task CancelTimerAsync()
    {
        await SleepTimerService.CancelAsync();
        _startedMessage = "Sleep timer disabled.";
    }

    private void BackToPlayer()
    {
        Navigation.NavigateTo($"/audiobooks/player/{BookId:D}/{ChapterId:D}");
    }

    private void OnSleepTimerStateChanged(object? sender, PlayTale.Features.Audiobooks.Models.SleepTimerState state)
    {
        _state = state;
        UpdateCountdownTicker();
        _ = InvokeAsync(StateHasChanged);
    }

    private static string GetActiveText(PlayTale.Features.Audiobooks.Models.SleepTimerState state)
    {
        return state.Mode switch
        {
            PlayTale.Features.Audiobooks.Models.SleepTimerMode.Duration when state.EndsAtUtc is not null
                => $"Stops in {FormatRemaining(state.EndsAtUtc.Value)}",
            PlayTale.Features.Audiobooks.Models.SleepTimerMode.EndOfChapter
                => "Will stop at end of current chapter.",
            PlayTale.Features.Audiobooks.Models.SleepTimerMode.ChapterCount
                => $"Will stop after {state.RemainingChapters ?? 0} chapter(s).",
            _ => "Sleep timer inactive."
        };
    }

    private static string FormatRemaining(DateTimeOffset endsAtUtc)
    {
        var remaining = endsAtUtc - DateTimeOffset.UtcNow;
        if (remaining < TimeSpan.Zero)
        {
            return "00:00";
        }

        return remaining.TotalHours >= 1
            ? remaining.ToString(@"hh\:mm\:ss")
            : remaining.ToString(@"mm\:ss");
    }

    public void Dispose()
    {
        StopCountdownTicker();
        SleepTimerService.SleepTimerStateChanged -= OnSleepTimerStateChanged;
    }

    private void UpdateCountdownTicker()
    {
        if (_state.IsActive && _state.Mode == PlayTale.Features.Audiobooks.Models.SleepTimerMode.Duration)
        {
            StartCountdownTicker();
        }
        else
        {
            StopCountdownTicker();
        }
    }

    private void StartCountdownTicker()
    {
        if (_countdownCts is not null)
        {
            return;
        }

        _countdownCts = new CancellationTokenSource();
        _ = RunCountdownTickerAsync(_countdownCts.Token);
    }

    private async Task RunCountdownTickerAsync(CancellationToken token)
    {
        try
        {
            using var timer = new PeriodicTimer(TimeSpan.FromSeconds(1));
            while (await timer.WaitForNextTickAsync(token))
            {
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
        }
    }

    private void StopCountdownTicker()
    {
        if (_countdownCts is null)
        {
            return;
        }

        _countdownCts.Cancel();
        _countdownCts.Dispose();
        _countdownCts = null;
    }
}
