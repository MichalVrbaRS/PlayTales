@page "/"
@page "/audiobooks"
@inject PlayTale.Features.Audiobooks.Services.ILibraryService LibraryService
@inject NavigationManager Navigation
@using Microsoft.AspNetCore.Components

<PageTitle>Audiobooks</PageTitle>

<section class="screen">
    <header class="screen__header">
        <h1>Audiobooks</h1>
        <div class="header-actions">
            <button type="button" class="icon-btn icon-btn--ghost" title="Search" @onclick="ToggleSearch">
                ⌕
            </button>
            <button type="button" class="icon-btn" title="Import audiobook" disabled="@_isImporting" @onclick="ImportAsync">
                @(_isImporting ? "…" : "⬇")
            </button>
        </div>
    </header>

    @if (_isSearchOpen)
    {
        <div class="search-panel">
            <input type="search"
                   class="search-input"
                   placeholder="Search books..."
                   value="@_searchQuery"
                   @oninput="OnSearchInput" />
            @if (!string.IsNullOrWhiteSpace(_searchQuery))
            {
                <button type="button" class="icon-btn icon-btn--ghost search-clear" title="Clear search" @onclick="ClearSearch">
                    ✕
                </button>
            }
        </div>
    }

    <div class="brand-hero" aria-hidden="true">
        <img src="/images/playtaleappicon.png?v=20260224-2" alt="PlayTale" />
    </div>

    @if (!string.IsNullOrWhiteSpace(_error))
    {
        <div class="state-panel state-panel--error">
            <div class="state-panel__title">Import failed</div>
            <div class="state-panel__text">@_error</div>
        </div>
    }

    @if (_books.Count == 0)
    {
        <div class="empty-state">
            <p>No audiobooks yet</p>
            <button type="button" class="primary-btn" disabled="@_isImporting" @onclick="ImportAsync">
                ⬇ Import
            </button>
        </div>
    }
    else
    {
        <div class="book-list">
            @foreach (var book in FilteredBooks)
            {
                <button type="button" class="book-row" @onclick="() => OpenBook(book.Id)">
                    <div class="book-row__cover">
                        @{
                            var coverDataUri = GetCoverDataUri(book.CoverPath);
                        }
                        @if (!string.IsNullOrWhiteSpace(coverDataUri))
                        {
                            <img src="@coverDataUri" alt="@book.Title cover" />
                        }
                        else
                        {
                            @GetCoverGlyph(book.Title)
                        }
                    </div>
                    <div class="book-row__meta">
                        <div class="book-row__title">@book.Title</div>
                        <div class="book-row__subtitle">@GetProgressText(book)</div>
                    </div>
                    <div class="book-row__chevron">›</div>
                </button>
            }
        </div>

        @if (FilteredBooks.Count == 0)
        {
            <div class="state-panel">
                <div class="state-panel__title">No results</div>
                <div class="state-panel__text">Try a different title or clear search.</div>
            </div>
        }
    }

    <PlayTale.Components.Shared.Audiobooks.MiniPlayer />
</section>

@code {
    private readonly List<PlayTale.Features.Audiobooks.Models.Book> _books = new();
    private readonly Dictionary<string, string> _coverDataUriCache = new(StringComparer.OrdinalIgnoreCase);
    private bool _isImporting;
    private bool _reimportAttempted;
    private bool _isSearchOpen;
    private string _searchQuery = string.Empty;
    private string? _error;

    [Parameter]
    [SupplyParameterFromQuery(Name = "reimport")]
    public bool? Reimport { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await LoadBooksAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (Reimport == true && !_reimportAttempted)
        {
            _reimportAttempted = true;
            await ImportAsync();
            Navigation.NavigateTo("/audiobooks", replace: true);
        }
    }

    private async Task LoadBooksAsync()
    {
        _error = null;
        _books.Clear();
        var books = await LibraryService.GetLibraryAsync();
        _books.AddRange(books);
    }

    private async Task ImportAsync()
    {
        if (_isImporting)
        {
            return;
        }

        try
        {
            _isImporting = true;
            _error = null;
            var book = await LibraryService.ImportAsync();
            await LoadBooksAsync();
            OpenBook(book.Id);
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            _isImporting = false;
        }
    }

    private void OpenBook(Guid bookId)
    {
        Navigation.NavigateTo($"/audiobooks/book/{bookId:D}");
    }

    private IReadOnlyList<PlayTale.Features.Audiobooks.Models.Book> FilteredBooks
    {
        get
        {
            if (string.IsNullOrWhiteSpace(_searchQuery))
            {
                return _books;
            }

            var query = _searchQuery.Trim();
            return _books
                .Where(book => book.Title.Contains(query, StringComparison.OrdinalIgnoreCase))
                .ToList();
        }
    }

    private void ToggleSearch()
    {
        _isSearchOpen = !_isSearchOpen;
        if (!_isSearchOpen)
        {
            _searchQuery = string.Empty;
        }
    }

    private void OnSearchInput(ChangeEventArgs args)
    {
        _searchQuery = args.Value?.ToString() ?? string.Empty;
    }

    private void ClearSearch()
    {
        _searchQuery = string.Empty;
    }

    private static string GetProgressText(PlayTale.Features.Audiobooks.Models.Book book)
    {
        if (book.LastPositionSeconds <= 0)
        {
            return "Not started";
        }

        return $"Chapter {book.LastChapterIndex + 1} at {FormatTime(book.LastPositionSeconds)}";
    }

    private static string FormatTime(double seconds)
    {
        var ts = TimeSpan.FromSeconds(Math.Max(0, seconds));
        return ts.TotalHours >= 1 ? ts.ToString(@"hh\:mm\:ss") : ts.ToString(@"mm\:ss");
    }

    private static string GetCoverGlyph(string title)
    {
        return string.IsNullOrWhiteSpace(title) ? "A" : title.Trim()[0].ToString().ToUpperInvariant();
    }

    private string? GetCoverDataUri(string? path)
    {
        if (string.IsNullOrWhiteSpace(path) || !File.Exists(path))
        {
            return null;
        }

        if (_coverDataUriCache.TryGetValue(path, out var cached))
        {
            return cached;
        }

        try
        {
            var bytes = File.ReadAllBytes(path);
            var mimeType = GetImageMimeType(path);
            var dataUri = $"data:{mimeType};base64,{Convert.ToBase64String(bytes)}";
            _coverDataUriCache[path] = dataUri;
            return dataUri;
        }
        catch
        {
            return null;
        }
    }

    private static string GetImageMimeType(string path)
    {
        var extension = Path.GetExtension(path);
        return extension.Equals(".png", StringComparison.OrdinalIgnoreCase)
            ? "image/png"
            : "image/jpeg";
    }
}
