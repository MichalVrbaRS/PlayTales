@page "/audiobooks/book/{BookId:guid}"
@implements IDisposable
@inject PlayTale.Features.Audiobooks.Services.ILibraryService LibraryService
@inject PlayTale.Features.Audiobooks.Services.IAudioService AudioService
@inject NavigationManager Navigation

<PageTitle>Book</PageTitle>

<section class="screen">
    <header class="header">
        <button type="button" class="link-btn" @onclick="BackToLibrary">‹</button>
        <h1>@(_book?.Title ?? "Book")</h1>
    </header>

    @if (_book is null)
    {
        <p>Book not found.</p>
    }
    else
    {
        @if (!string.IsNullOrWhiteSpace(_playbackError))
        {
            <div class="missing-file">
                <p>@_playbackError</p>
                <div class="missing-file__actions">
                    <button type="button" class="secondary-btn" @onclick="ReimportBook">Re-import Audiobook</button>
                    <button type="button" class="danger-btn" @onclick="ArmDelete">Remove From Library</button>
                </div>
            </div>
        }

        <div class="cover">
            @{
                var coverDataUri = GetCoverDataUri(_book.CoverPath);
            }
            @if (!string.IsNullOrWhiteSpace(coverDataUri))
            {
                <img src="@coverDataUri" alt="@_book.Title cover" />
            }
            else
            {
                @GetCoverGlyph(_book.Title)
            }
        </div>

        <button type="button" class="primary-btn" @onclick="ResumeAsync">
            Continue
        </button>

        <div class="actions">
            @if (!_confirmDelete)
            {
                <button type="button" class="danger-btn" disabled="@_isDeleting" @onclick="ArmDelete">
                    Remove From Library
                </button>
            }
            else
            {
                <button type="button" class="danger-btn" disabled="@_isDeleting" @onclick="DeleteBookAsync">
                    @(_isDeleting ? "Removing..." : "Confirm Remove")
                </button>
                <button type="button" class="secondary-btn" disabled="@_isDeleting" @onclick="CancelDelete">
                    Cancel
                </button>
            }
        </div>

        @if (!string.IsNullOrWhiteSpace(_error))
        {
            <p class="error">@_error</p>
        }

        <div class="chapters">
            @foreach (var chapter in _chapters)
            {
                var isCurrent = AudioService.CurrentState.ChapterId == chapter.Id;
                <button type="button" class="chapter @(isCurrent ? "chapter--current" : string.Empty)" @onclick="() => StartChapterAsync(chapter)">
                    <span>@chapter.Title</span>
                    <span>›</span>
                </button>
            }
        </div>
    }

    <PlayTale.Components.Shared.Audiobooks.MiniPlayer />
</section>

@code {
    [Parameter]
    public Guid BookId { get; set; }

    private PlayTale.Features.Audiobooks.Models.Book? _book;
    private IReadOnlyList<PlayTale.Features.Audiobooks.Models.Chapter> _chapters = Array.Empty<PlayTale.Features.Audiobooks.Models.Chapter>();
    private readonly Dictionary<string, string> _coverDataUriCache = new(StringComparer.OrdinalIgnoreCase);
    private bool _confirmDelete;
    private bool _isDeleting;
    private string? _error;
    private string? _playbackError;

    protected override async Task OnInitializedAsync()
    {
        AudioService.PlaybackStateChanged += OnPlaybackStateChanged;
        await LoadAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        await LoadAsync();
    }

    private async Task LoadAsync()
    {
        _error = null;
        _playbackError = null;
        _book = await LibraryService.GetBookAsync(BookId);
        _chapters = await LibraryService.GetChaptersAsync(BookId);
    }

    private async Task ResumeAsync()
    {
        if (_book is null || _chapters.Count == 0)
        {
            return;
        }

        var index = Math.Clamp(_book.LastChapterIndex, 0, _chapters.Count - 1);
        var chapter = _chapters[index];
        var start = Math.Max(0, _book.LastPositionSeconds - 10);
        try
        {
            AudioService.SetNowPlayingMetadata(_book.Title, chapter.Title);
            await AudioService.PlayAsync(chapter, start);
            Navigation.NavigateTo($"/audiobooks/player/{BookId:D}/{chapter.Id:D}");
        }
        catch (FileNotFoundException)
        {
            _playbackError = "File unavailable. The source audio was moved or deleted.";
        }
    }

    private async Task StartChapterAsync(PlayTale.Features.Audiobooks.Models.Chapter chapter)
    {
        try
        {
            AudioService.SetNowPlayingMetadata(_book?.Title, chapter.Title);
            await AudioService.PlayAsync(chapter);
            Navigation.NavigateTo($"/audiobooks/player/{BookId:D}/{chapter.Id:D}");
        }
        catch (FileNotFoundException)
        {
            _playbackError = "File unavailable. The selected chapter cannot be opened.";
        }
    }

    private void BackToLibrary()
    {
        Navigation.NavigateTo("/audiobooks");
    }

    private void ReimportBook()
    {
        Navigation.NavigateTo("/audiobooks?reimport=true");
    }

    private void ArmDelete()
    {
        _confirmDelete = true;
        _error = null;
    }

    private void CancelDelete()
    {
        _confirmDelete = false;
    }

    private async Task DeleteBookAsync()
    {
        try
        {
            _isDeleting = true;
            _error = null;

            if (AudioService.CurrentState.BookId == BookId)
            {
                await AudioService.StopAsync();
            }

            await LibraryService.DeleteBookAsync(BookId);
            Navigation.NavigateTo("/audiobooks");
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            _isDeleting = false;
        }
    }

    private void OnPlaybackStateChanged(object? sender, PlayTale.Features.Audiobooks.Models.PlaybackState e)
    {
        _ = InvokeAsync(StateHasChanged);
    }

    private static string GetCoverGlyph(string title)
    {
        return string.IsNullOrWhiteSpace(title) ? "A" : title.Trim()[0].ToString().ToUpperInvariant();
    }

    private string? GetCoverDataUri(string? path)
    {
        if (string.IsNullOrWhiteSpace(path) || !File.Exists(path))
        {
            return null;
        }

        if (_coverDataUriCache.TryGetValue(path, out var cached))
        {
            return cached;
        }

        try
        {
            var bytes = File.ReadAllBytes(path);
            var mimeType = GetImageMimeType(path);
            var dataUri = $"data:{mimeType};base64,{Convert.ToBase64String(bytes)}";
            _coverDataUriCache[path] = dataUri;
            return dataUri;
        }
        catch
        {
            return null;
        }
    }

    private static string GetImageMimeType(string path)
    {
        var extension = Path.GetExtension(path);
        return extension.Equals(".png", StringComparison.OrdinalIgnoreCase)
            ? "image/png"
            : "image/jpeg";
    }

    public void Dispose()
    {
        AudioService.PlaybackStateChanged -= OnPlaybackStateChanged;
    }
}
